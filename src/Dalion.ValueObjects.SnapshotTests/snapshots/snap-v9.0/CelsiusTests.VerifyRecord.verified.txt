[  
using System;

namespace Dalion.ValueObjects
{
    // ReSharper disable once RedundantNullableDirective
#nullable enable
    /// <inheritdoc/>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
    public class ValueObjectAttribute<T> : ValueObjectAttribute
    {
        /// <summary>
        ///     Configures aspects of this individual value object.
        /// </summary>
        /// <param name = "comparison">
        ///     Species which comparison code is generated—defaults to
        ///     <see cref = "ComparisonGeneration.UseUnderlying"/> which hoists any IComparable implementations from the underlying
        ///     type.
        /// </param>
        /// <param name = "toUnderlyingTypeCasting">
        ///     Controls how cast operators are generated for casting from the Value Object to the underlying type.
        ///     Options are implicit or explicit or none.  Explicit is preferred over implicit if you really need them, but isn't
        ///     recommended.
        /// </param>
        /// <param name = "fromUnderlyingTypeCasting">
        ///     Controls how cast operators are generated for casting from the underlying type to the Value Object.
        ///     Options are implicit or explicit or none.  Explicit is preferred over implicit if you really need them, but isn't
        ///     recommended.
        /// </param>
        /// <param name = "stringCaseSensitivity">
        ///     When using a <see cref = "string "/> as a backing value, controls whether comparisons are case-sensitive.
        ///     Defaults to <see cref = "StringCaseSensitivity.CaseSensitive"/>.
        /// </param>
        /// <param name = "underlyingTypeEqualityGeneration">
        ///     Specifies whether to generate underlying type comparison operators, allowing this type to be compared for equality
        ///     to the
        ///     underlying type.
        ///     Defaults to <see cref = "UnderlyingTypeEqualityGeneration.Omit"/>
        /// </param>
        /// <param name = "fluentValidationExtensionsGeneration">
        ///     Specifies whether to generate FluentValidation extension methods for this value object.
        ///     Defaults to <see cref = "FluentValidationExtensionsGeneration.Omit"/>.
        /// </param>
        /// <param name = "parsableGeneration">
        ///     Defines if IParsable implementation and related methods are generated. Defaults to
        ///     <see cref = "ParsableGeneration.Generate"/>.
        /// </param>
        /// <param name = "underlyingTypeCreationMethodGeneration">
        ///     Defines if an extension method for value object creation is generated for the underlying type.
        ///     Defaults to <see cref = "UnderlyingTypeCreationMethodGeneration.Omit"/>.
        /// </param>
        /// <param name = "emptyValueName">
        ///     The name of the static property representing an empty value object, if applicable.
        ///     Defaults to "Empty".
        /// </param>
        public ValueObjectAttribute(ComparisonGeneration comparison = DefaultComparison, CastOperator toUnderlyingTypeCasting = DefaultToUnderlyingTypeCasting, CastOperator fromUnderlyingTypeCasting = DefaultFromUnderlyingTypeCasting, StringCaseSensitivity stringCaseSensitivity = DefaultStringCaseSensitivity, UnderlyingTypeEqualityGeneration underlyingTypeEqualityGeneration = DefaultUnderlyingTypeEqualityGeneration, FluentValidationExtensionsGeneration fluentValidationExtensionsGeneration = DefaultFluentValidationExtensionsGeneration, ParsableGeneration parsableGeneration = DefaultParsableGeneration, UnderlyingTypeCreationMethodGeneration underlyingTypeCreationMethodGeneration = DefaultUnderlyingTypeCreationMethodGeneration, string emptyValueName = DefaultEmptyValueName) : base(typeof(T), comparison, toUnderlyingTypeCasting, fromUnderlyingTypeCasting, stringCaseSensitivity, underlyingTypeEqualityGeneration, fluentValidationExtensionsGeneration, parsableGeneration, underlyingTypeCreationMethodGeneration, emptyValueName)
        {
        }
    }

    /// <summary>
    ///     Marks a type as a Value Object. The type that this is applied to should be partial so that the
    ///     source generator can augment it with equality, creation barriers, and any conversions.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
    public class ValueObjectAttribute : Attribute
    {
        internal const ComparisonGeneration DefaultComparison = ComparisonGeneration.UseUnderlying;
        internal const CastOperator DefaultToUnderlyingTypeCasting = CastOperator.None;
        internal const CastOperator DefaultFromUnderlyingTypeCasting = CastOperator.None;
        internal const StringCaseSensitivity DefaultStringCaseSensitivity = StringCaseSensitivity.CaseSensitive;
        internal const UnderlyingTypeEqualityGeneration DefaultUnderlyingTypeEqualityGeneration = UnderlyingTypeEqualityGeneration.Omit;
        internal const FluentValidationExtensionsGeneration DefaultFluentValidationExtensionsGeneration = FluentValidationExtensionsGeneration.Omit;
        internal const ParsableGeneration DefaultParsableGeneration = ParsableGeneration.Generate;
        internal const UnderlyingTypeCreationMethodGeneration DefaultUnderlyingTypeCreationMethodGeneration = UnderlyingTypeCreationMethodGeneration.Omit;
        internal const string DefaultEmptyValueName = "Empty";
        /// <summary>
        ///     Configures aspects of this individual value object.
        /// </summary>
        /// <param name = "underlyingType">The type of the underlying value that is being wrapped.</param>
        /// <param name = "comparison">
        ///     Species which comparison code is generated—defaults to
        ///     <see cref = "ComparisonGeneration.UseUnderlying"/> which hoists any IComparable implementations from the underlying
        ///     type.
        /// </param>
        /// <param name = "toUnderlyingTypeCasting">
        ///     Specifies the type of casting from wrapper to the underlying type - defaults to
        ///     <see cref = "CastOperator.Explicit"/>.
        /// </param>
        /// <param name = "fromUnderlyingTypeCasting">
        ///     Specifies the type of casting from the underlying type to wrapper - default to
        ///     <see cref = "CastOperator.Explicit"/>.
        /// </param>
        /// <param name = "stringCaseSensitivity">
        ///     When using a <see cref = "string "/> as a backing value, controls whether comparisons are case-sensitive.
        ///     Defaults to <see cref = "StringCaseSensitivity.CaseSensitive"/>.
        /// </param>
        /// <param name = "underlyingTypeEqualityGeneration">
        ///     Specifies whether to generate underlying value comparison operators, allowing this type to be compared for equality
        ///     to the
        ///     underlying type.
        ///     Defaults to <see cref = "UnderlyingTypeEqualityGeneration.Omit"/>
        /// </param>
        /// <param name = "fluentValidationExtensionsGeneration">
        ///     Specifies whether to generate FluentValidation extension methods for this value object.
        ///     Defaults to <see cref = "FluentValidationExtensionsGeneration.Omit"/>.
        /// </param>
        /// <param name = "parsableGeneration">
        ///     Defines if IParsable implementation and related methods are generated. Defaults to
        ///     <see cref = "ParsableGeneration.Generate"/>.
        /// </param>
        /// <param name = "underlyingTypeCreationMethodGeneration">
        ///     Defines if an extension method for value object creation is generated for the underlying type.
        ///     Defaults to <see cref = "UnderlyingTypeCreationMethodGeneration.Omit"/>.
        /// </param>
        /// <param name = "emptyValueName">
        ///     The name of the static property representing an empty value object, if applicable.
        ///     Defaults to "Empty".
        /// </param>
        public ValueObjectAttribute(Type? underlyingType = null !, ComparisonGeneration comparison = DefaultComparison, CastOperator toUnderlyingTypeCasting = DefaultToUnderlyingTypeCasting, CastOperator fromUnderlyingTypeCasting = DefaultFromUnderlyingTypeCasting, StringCaseSensitivity stringCaseSensitivity = DefaultStringCaseSensitivity, UnderlyingTypeEqualityGeneration underlyingTypeEqualityGeneration = DefaultUnderlyingTypeEqualityGeneration, FluentValidationExtensionsGeneration fluentValidationExtensionsGeneration = DefaultFluentValidationExtensionsGeneration, ParsableGeneration parsableGeneration = DefaultParsableGeneration, UnderlyingTypeCreationMethodGeneration underlyingTypeCreationMethodGeneration = DefaultUnderlyingTypeCreationMethodGeneration, string emptyValueName = DefaultEmptyValueName)
        {
        }
    }

    /// <summary>
    ///     The type of cast operator to generate.
    /// </summary>
    public enum CastOperator
    {
        /// <summary>
        ///     No cast operators are generated.
        /// </summary>
        None = 0,
        /// <summary>
        ///     Explicit cast operators are generated.
        /// </summary>
        Explicit = 1,
        /// <summary>
        ///     Implicit cast operators are generated.
        /// </summary>
        Implicit = 2,
    }

    /// <summary>
    ///     The generation of comparison code for a Value Object.
    /// </summary>
    public enum ComparisonGeneration
    {
        /// <summary>
        ///     Omits the IComparable interface and implementation. Useful for opaque types such as tokens or IDs where comparison
        ///     doesn't make sense.
        /// </summary>
        Omit = 0,
        /// <summary>
        ///     Uses the default IComparable from the underlying type.
        /// </summary>
        UseUnderlying = 1,
    }

    /// <summary>
    ///     Specifies whether to generate string comparers for a value object based on a string primitive type.
    /// </summary>
    public enum StringCaseSensitivity
    {
        /// <summary>
        ///     The backing string values are case-sensitive.
        /// </summary>
        CaseSensitive = 0,
        /// <summary>
        ///     The backing string values are case-sensitive.
        /// </summary>
        CaseInsensitive = 1,
    }

    /// <summary>
    ///     Defines if equality operators to the underlying values are generated.
    /// </summary>
    [Flags]
    public enum UnderlyingTypeEqualityGeneration
    {
        /// <summary>
        ///     Do not generate.
        /// </summary>
        Omit = 0,
        /// <summary>
        ///     Generate equals operators for the underlying type.
        /// </summary>
        GenerateOperators = 1 << 0,
        /// <summary>
        ///     Generate equals methods for the underlying type.
        /// </summary>
        GenerateMethods = 1 << 1,
        /// <summary>
        ///     Generate both operators and methods.
        /// </summary>
        GenerateOperatorsAndMethods = GenerateOperators | GenerateMethods,
    }

    /// <summary>
    ///     Defines if FluentValidation extension methods are generated.
    /// </summary>
    [Flags]
    public enum FluentValidationExtensionsGeneration
    {
        /// <summary>
        ///     Do not generate.
        /// </summary>
        Omit = 0,
        /// <summary>
        ///     Generate MustBeInitialized extension method.
        /// </summary>
        GenerateMustBeInitialized = 1 << 0,
        /// <summary>
        ///     Generate MustBeInitializedAndValid extension method.
        /// </summary>
        GenerateMustBeInitializedAndValid = 1 << 1,
        /// <summary>
        ///     Generate all methods.
        /// </summary>
        GenerateAll = GenerateMustBeInitialized | GenerateMustBeInitializedAndValid,
    }

    /// <summary>
    ///     Defines if IParsable implementation and related methods are generated.
    /// </summary>
    public enum ParsableGeneration
    {
        /// <summary>
        ///     Do not generate.
        /// </summary>
        Omit = 0,
        /// <summary>
        ///     Generate IParsable implementation and related methods.
        /// </summary>
        Generate = 1,
    }

    /// <summary>
    ///     Defines if an extension method for value object creation is generated for the underlying type.
    /// </summary>
    public enum UnderlyingTypeCreationMethodGeneration
    {
        /// <summary>
        ///     Do not generate.
        /// </summary>
        Omit = 0,
        /// <summary>
        ///     Generate Create method.
        /// </summary>
        Generate = 1,
    }
}
  
#nullable enable

using System;

namespace Dalion.ValueObjects.Samples {
    
    [System.Diagnostics.DebuggerDisplay("Celsius {Value}")]
    [System.Text.Json.Serialization.JsonConverter(typeof(CelsiusSystemTextJsonConverter))]
    [System.ComponentModel.TypeConverter(typeof(CelsiusTypeConverter))]
    public partial record struct Celsius : IEquatable<Celsius>, IFormattable, IEquatable<System.Decimal>, ISpanParsable<Celsius>, IUtf8SpanParsable<Celsius>, IComparable<Celsius>, IComparable {
        private readonly System.Decimal _value;
        private readonly bool _initialized;
#pragma warning disable CS0414
        private readonly bool _isNullOrEmpty;
#pragma warning restore CS0414
        private readonly Validation _validation;
        private static readonly Type UnderlyingType = typeof(System.Decimal);

        /// <summary>
        ///     Gets the underlying value of this <see cref="Celsius"/>.
        /// </summary>
        public System.Decimal Value => _value;

        /// <summary>
        ///     Creates a new <see cref="Celsius"/>.
        /// </summary>
        [System.Diagnostics.DebuggerStepThrough]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Celsius()
        {
            _value = default;
            _initialized = false;
            _isNullOrEmpty = false;
            _validation ??= Validate(_value);
        }

        /// <summary>
        ///     Creates a new <see cref="Celsius"/>.
        /// </summary>
        /// <param name="value">The underlying value to create the value object from.</param>
        [System.Diagnostics.DebuggerStepThrough]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        private Celsius(System.Decimal value) {
            
            _initialized = true;
            _value = value;
            _isNullOrEmpty = false;
            _validation ??= Validate(_value);
        }

        /// <summary>
        ///     Creates a new <see cref="Celsius"/> from the
        ///     given <see cref="System.Decimal"/>.
        /// </summary>
        /// <param name="value">The underlying value to create the value object from.</param>
        /// <returns>A new <see cref="Celsius"/>.</returns>
        public static Celsius From(System.Decimal value) {
            if (value == default) {
                return Zero;
            }

            var vo = new Celsius(value);

            if (!vo.IsValid() && !CelsiusPreSetValueCache.CelsiusPreSetValues.TryGetValue(vo.Value, out _)) {
                throw new System.ArgumentException(vo.GetValidationErrorMessage());
            }

            return vo;
        }

        /// <summary>
        ///     Tries to create a new <see cref="Celsius"/> from the
        ///     given <see cref="System.Decimal"/>.
        /// </summary>
        /// <param name="value">The underlying value to create the value object from.</param>
        /// <param name="result">The resulting value object if the method returns <see langword="true"/>; otherwise, an uninitialized value object.</param>
        /// <returns><see langword="true"/> if the value object was created successfully; otherwise, <see langword="false"/>.</returns>
        public static bool TryFrom(System.Decimal value, out Celsius result) {
            result = value == default ? Zero : new Celsius(value);
            return result.IsInitialized() && (Validate(result._value).IsSuccess || CelsiusPreSetValueCache.CelsiusPreSetValues.TryGetValue(value, out _));
        }

        /// <summary>
        ///     Represents a <see cref="Celsius"/> with a default underlying value.
        /// </summary>
        public static Celsius Zero { get; } = new Celsius(default);

        /// <summary>
        ///     Indicates whether this <see cref="Celsius"/> has been
        ///     initialized with a value.
        /// </summary>
        /// <returns><see langword="true" /> if this <see cref="Celsius"/> has been initialized; otherwise, <see langword="false" />.</returns>
        public bool IsInitialized() => _initialized;

        /// <inheritdoc />
        public bool Equals(Celsius? other)
        {
            if (other is null) return false;

            if (!other.Value.IsInitialized())
            {
                return !IsInitialized();
            }

            if (other.Value.IsInitialized() != IsInitialized())
            {
                return false;
            }
        
            return System.Collections.Generic.EqualityComparer<System.Decimal>.Default.Equals(this._value, other.Value.Value);
        }

        /// <inheritdoc />
        public bool Equals(Celsius other)
        {
            if (!other.IsInitialized())
            {
                return !IsInitialized();
            }

            if (other.IsInitialized() != IsInitialized())
            {
                return false;
            }
        
            return System.Collections.Generic.EqualityComparer<System.Decimal>.Default.Equals(this._value, other.Value);
        }
        
        /// <inheritdoc />
        public bool Equals(Celsius? other, System.Collections.Generic.IEqualityComparer<Celsius> comparer)
        {
            if (other is null) return false;
            return comparer.Equals(this, other.Value);
        }
        
        /// <inheritdoc />
        public override int GetHashCode() {
            if (!IsInitialized()) return 0;
            return System.Collections.Generic.EqualityComparer<System.Decimal>.Default.GetHashCode(this._value);
        }

        /// <inheritdoc />
        public bool Equals(System.Decimal other)
        {
            return System.Collections.Generic.EqualityComparer<System.Decimal>.Default.Equals(this._value, other);
        }

        /// <summary>
        ///     The equality operator for <see cref="Celsius" /> and <see cref="System.Decimal" />.
        /// </summary>
        /// <returns><see langword="true" /> if the specified items are considered equal; otherwise, <see langword="false" />.</returns>
        public static bool operator ==(Celsius left, System.Decimal right) => left.Value.Equals(right);

        /// <summary>
        ///     The equality operator for <see cref="System.Decimal" /> and <see cref="Celsius" />.
        /// </summary>
        /// <returns><see langword="true" /> if the specified items are considered equal; otherwise, <see langword="false" />.</returns>
        public static bool operator ==(System.Decimal left, Celsius right) => right.Value.Equals(left);

        /// <summary>
        ///     The inequality operator for <see cref="Celsius" /> and <see cref="System.Decimal" />.
        /// </summary>
        /// <returns><see langword="true" /> if the specified items are considered not to be equal; otherwise, <see langword="false" />.</returns>
        public static bool operator !=(Celsius left, System.Decimal right) => !(left == right);

        /// <summary>
        ///     The inequality operator for <see cref="System.Decimal" /> and <see cref="Celsius" />.
        /// </summary>
        /// <returns><see langword="true" /> if the specified items are considered not to be equal; otherwise, <see langword="false" />.</returns>
        public static bool operator !=(System.Decimal left, Celsius right) => !(left == right);

        /// <inheritdoc />
        public int CompareTo(Celsius other) => this.Value.CompareTo(other.Value);

        /// <inheritdoc />
        public int CompareTo(System.Decimal other) => this.Value.CompareTo(other);
        
        /// <inheritdoc />
        public int CompareTo(object? other)
        {
            if (other == null)
                return 1;
            if (other is Celsius other1)
                return this.CompareTo(other1);
            if (other is System.Decimal v)
                return this.CompareTo(v);
            throw new System.ArgumentException(
                "Cannot compare to object as it is not of type Celsius",
                nameof(other)
            );
        }

        /// <summary>
        ///     An implicit conversion from <see cref="Celsius" /> to <see cref="System.Decimal" />.
        /// </summary>
        /// <param name="id">The value to convert.</param>
        /// <returns>The System.Decimal representation of the value object.</returns>
        public static explicit operator System.Decimal(Celsius id)
        {
            return id.Value;
        }

        /// <summary>
        ///     An explicit conversion from <see cref="System.Decimal" /> to <see cref="Celsius" />.
        /// </summary>
        /// <param name="value">The value to convert.</param>
        /// <returns>The <see cref="Celsius" /> instance created from the input value.</returns>
        public static explicit operator Celsius(System.Decimal value)
        {
            return Celsius.From(value);
        }

        /// <inheritdoc />
        public override string ToString()
        {
            return Value.ToString();
        }

        /// <inheritdoc cref="M:System.String.ToString(System.IFormatProvider)" />
        public string ToString(IFormatProvider? provider)
        {
            return Value.ToString(format: null, provider: provider) ?? "";
        }

        /// <inheritdoc />
        public string ToString(string? format, IFormatProvider? formatProvider)
        {{
            return Value.ToString(format, formatProvider) ?? "";
        }}

        /// <summary>
        ///     Indicates whether this value object is valid.
        /// </summary>
        /// <returns><see langword="true" /> if this value object is valid; otherwise, <see langword="false" />.</returns>
        public bool IsValid() => _validation.IsSuccess;

        /// <summary>
        ///     Gets the validation error message if this value object is not valid.
        /// </summary>
        /// <returns>The validation error message if this value object is not valid; otherwise, <see langword="null" />.</returns>
        public string? GetValidationErrorMessage() => _validation.IsSuccess ? null : _validation.ErrorMessage;

        private class Validation
        {
            public static readonly Validation Ok = new(string.Empty);
            private readonly bool _isSuccess;
        
            private Validation(string reason)
            {
                ErrorMessage = reason;
                _isSuccess = string.IsNullOrEmpty(reason);
            }
        
            public string ErrorMessage { get; }
            public bool IsSuccess => _isSuccess;
        
            public System.Collections.Generic.Dictionary<object, object>? Data { get; private set; }
        
            public static Validation Invalid(string reason = "")
            {
                if (string.IsNullOrEmpty(reason))
                {
                    return new Validation("[none provided]");
                }
        
                return new Validation(reason);
            }
        
            public Validation WithData(object key, object value)
            {
                Data ??= new System.Collections.Generic.Dictionary<object, object>();
                Data[key] = value;
                return this;
            }
        }

        /// <inheritdoc />
        public static Celsius Parse(string s, IFormatProvider? provider)
        {
            var v = System.Decimal.Parse(s, provider);
            return From(v);
        }

        /// <inheritdoc />
        public static bool TryParse(
            string? s,
            IFormatProvider? provider,
            out Celsius result
        )
        {
            try
            {
                var v = s == null ? default : System.Decimal.Parse(s, provider);
                return TryFrom(v, out result);
            }
            catch (ArgumentException)
            {
                result = default;
                return false;
            }
            catch (FormatException)
            {
                result = default;
                return false;
            }
        }

        /// <inheritdoc />
        public static Celsius Parse(ReadOnlySpan<char> s, IFormatProvider? provider)
        {
            var v = System.Decimal.Parse(s, provider);
            return From(v);
        }

        /// <inheritdoc />
        public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out Celsius result)
        {
            try
            {
                var v = System.Decimal.Parse(new string(s), provider);
                return TryFrom(v, out result);
            }
            catch (ArgumentException)
            {
                result = default;
                return false;
            }
            catch (FormatException)
            {
                result = default;
                return false;
            }
        }

        /// <inheritdoc />
        public static Celsius Parse(ReadOnlySpan<byte> utf8Text, IFormatProvider? provider)
        {
            var s = System.Text.Encoding.UTF8.GetString(utf8Text);
            var v = System.Decimal.Parse(s, provider);
            return From(v);
        }

        /// <inheritdoc />
        public static bool TryParse(
            ReadOnlySpan<byte> utf8Text,
            IFormatProvider? provider,
            out Celsius result
        )
        {
            try
            {
                var s = System.Text.Encoding.UTF8.GetString(utf8Text);
                var v = System.Decimal.Parse(s, provider);
                return TryFrom(v, out result);
            }
            catch (ArgumentException)
            {
                result = default;
                return false;
            }
            catch (FormatException)
            {
                result = default;
                return false;
            }
        }

        private class CelsiusSystemTextJsonConverter : System.Text.Json.Serialization.JsonConverter<Celsius>
        {
            public override Celsius Read(
                ref System.Text.Json.Utf8JsonReader reader,
                Type typeToConvert,
                System.Text.Json.JsonSerializerOptions options
            )
            {
                if (reader.TokenType == System.Text.Json.JsonTokenType.Null) {
                    return new Celsius();
                }

                object? underlyingValue;
                underlyingValue = reader.GetDecimal();

                try {
                    var typedUnderlyingValue = (System.Decimal)underlyingValue!;
                    if (Celsius.TryFrom(typedUnderlyingValue, out var result)) {
                        return result;
                    }
                    throw new System.Text.Json.JsonException($"No matching Celsius pre-set value found for value '{typedUnderlyingValue}', or the underlying value is invalid.");
                } catch (System.Exception e) {
                    throw new System.Text.Json.JsonException("Could not create an initialized instance of Celsius.", e);
                }
            }

            public override void Write(
                System.Text.Json.Utf8JsonWriter writer,
                Celsius value,
                System.Text.Json.JsonSerializerOptions options
            )
            {
                object? underlyingValue = value.IsInitialized()
                    ? value.Value
                    : null;

                if (underlyingValue == null) {
                    writer.WriteNullValue();
                    return;
                }

                writer.WriteNumberValue((decimal)underlyingValue);
            }
        }

        
        private class CelsiusTypeConverter : System.ComponentModel.TypeConverter
        {
            public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, Type sourceType)
            {
                return sourceType == UnderlyingType || sourceType == typeof(string);
            }
            
            public override object? ConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Globalization.CultureInfo? culture, object value)
            {
                if (value == null) return Zero;
        
                if (value.GetType() == UnderlyingType)
                {
                    var underlyingValue = GetUnderlyingValue(value);
                    return underlyingValue == default ? Zero : From((System.Decimal)underlyingValue);
                }
        
                if (value is string s)
                {
                    var underlyingValue = System.Decimal.Parse(s, culture ?? System.Globalization.CultureInfo.InvariantCulture);
                    return underlyingValue == default ? Zero : From((System.Decimal)underlyingValue);
                }
    
                throw new NotSupportedException($@"Cannot convert from type '{value?.GetType()}'.");
            }

            private object? GetUnderlyingValue(object? value) {
                if (value == null) {
                    return default(System.Decimal);
                }
        
                if (value is System.Decimal v) {
                    return v;
                }
                
                if (Type.GetTypeCode(typeof(System.Decimal)) == TypeCode.Object) {
                    throw new NotSupportedException($"Cannot convert value of type '{value?.GetType()}' to 'System.Decimal'.");
                }
                
                return Convert.ChangeType(value, typeof(System.Decimal));
            }
            
            public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext? context, Type? destinationType)
            {
                return destinationType == UnderlyingType || destinationType == typeof(string);
            }
            
            public override object? ConvertTo(System.ComponentModel.ITypeDescriptorContext? context, System.Globalization.CultureInfo? culture, object? value, Type destinationType)
            {
                if (destinationType == UnderlyingType)
                {
                    if (value is Celsius vo)
                    {
                        return vo.Value;
                    }
                    return base.ConvertTo(context, culture ?? System.Globalization.CultureInfo.InvariantCulture, value, destinationType);
                }

                if (destinationType == typeof(string))
                {
                    if (value is Celsius vo)
                    {
                        return vo.ToString(culture ?? System.Globalization.CultureInfo.InvariantCulture);
                    }
                    if (value is System.IFormattable f)
                    {
                        return f.ToString(format: null, formatProvider: culture ?? System.Globalization.CultureInfo.InvariantCulture);
                    }
                    return value?.ToString();
                }

                throw new NotSupportedException($@"Cannot convert to type '{destinationType}'.");
            }
        }


        private static class CelsiusPreSetValueCache {
            public static readonly System.Collections.Generic.Dictionary<System.Decimal, Celsius> CelsiusPreSetValues = new();
        
            static CelsiusPreSetValueCache()
            {
                CelsiusPreSetValues[Celsius.Zero.Value] = Celsius.Zero;
                CelsiusPreSetValues[Celsius.AbsoluteZero.Value] = Celsius.AbsoluteZero;
                CelsiusPreSetValues[Celsius.AbsoluteZeroFahrenheit.Value] = Celsius.AbsoluteZeroFahrenheit;
            }
        }
    }
    
}
  
#nullable enable

using System;
using FluentValidation;

namespace Dalion.ValueObjects.Samples {
    /// <summary>
    ///     Extension methods for FluentValidation to validate <see cref="Celsius"/> value objects.
    /// </summary>
    public static class CelsiusFluentValidationExtensions
    {
        /// <summary>
        ///     Validates that the value object is initialized.
        /// </summary>
        public static FluentValidation.IRuleBuilderOptions<T, Celsius> MustBeInitialized<T>(
            this FluentValidation.IRuleBuilderInitial<T, Celsius> ruleBuilder
        )
        {
            return ruleBuilder
                .Cascade(FluentValidation.CascadeMode.Stop)
                .Must(o => o.IsInitialized())
                .WithMessage($"{nameof(Celsius)} must be initialized.");
        }
    
        /// <summary>
        ///     Validates that the value object is initialized and valid.
        /// </summary>
        public static FluentValidation.IRuleBuilderOptions<T, Celsius> MustBeInitializedAndValid<T>(
            this FluentValidation.IRuleBuilderInitial<T, Celsius> ruleBuilder
        )
        {
            return ruleBuilder
                .Cascade(FluentValidation.CascadeMode.Stop)
                .Must(o => o.IsInitialized())
                .WithMessage($"{nameof(Celsius)} must be initialized.")
                .Must(o => o.IsValid())
                .WithMessage((_, p) => p.GetValidationErrorMessage());
        }
    }
}
  
#nullable enable

using System;

namespace Dalion.ValueObjects.Samples {
    /// <summary>
    ///     Extension methods to create <see cref="Celsius"/> value objects.
    /// </summary>
    public static class CelsiusUnderlyingTypeCreationExtensions
    {
        /// <summary>
        ///     Creates a new <see cref="Celsius"/> from the given <see cref="System.Decimal"/>.
        /// </summary>
        /// <param name="value">The value to create the value object from.</param>
        /// <returns>A new <see cref="Celsius"/>.</returns>
        public static Dalion.ValueObjects.Samples.Celsius Celsius(this System.Decimal value)
        {
            return Dalion.ValueObjects.Samples.Celsius.From(value);
        }
    }
}
]