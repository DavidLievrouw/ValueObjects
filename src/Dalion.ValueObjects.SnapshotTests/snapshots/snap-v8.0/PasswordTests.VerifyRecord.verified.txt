[  
using System;

namespace Dalion.ValueObjects
{
    // ReSharper disable once RedundantNullableDirective
#nullable enable
    /// <inheritdoc/>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
    public class ValueObjectAttribute<T> : ValueObjectAttribute
    {
        /// <summary>
        ///     Configures aspects of this individual value object.
        /// </summary>
        /// <param name = "comparison">
        ///     Species which comparison code is generated—defaults to
        ///     <see cref = "ComparisonGeneration.UseUnderlying"/> which hoists any IComparable implementations from the underlying
        ///     type.
        /// </param>
        /// <param name = "toUnderlyingTypeCasting">
        ///     Controls how cast operators are generated for casting from the Value Object to the underlying type.
        ///     Options are implicit or explicit or none.  Explicit is preferred over implicit if you really need them, but isn't
        ///     recommended.
        /// </param>
        /// <param name = "fromUnderlyingTypeCasting">
        ///     Controls how cast operators are generated for casting from the underlying type to the Value Object.
        ///     Options are implicit or explicit or none.  Explicit is preferred over implicit if you really need them, but isn't
        ///     recommended.
        /// </param>
        /// <param name = "stringCaseSensitivity">
        ///     When using a <see cref = "string "/> as a backing value, controls whether comparisons are case-sensitive.
        ///     Defaults to <see cref = "StringCaseSensitivity.CaseSensitive"/>.
        /// </param>
        /// <param name = "underlyingTypeEqualityGeneration">
        ///     Specifies whether to generate underlying type comparison operators, allowing this type to be compared for equality
        ///     to the
        ///     underlying type.
        ///     Defaults to <see cref = "UnderlyingTypeEqualityGeneration.Omit"/>
        /// </param>
        /// <param name = "fluentValidationExtensionsGeneration">
        ///     Specifies whether to generate FluentValidation extension methods for this value object.
        ///     Defaults to <see cref = "FluentValidationExtensionsGeneration.Omit"/>.
        /// </param>
        /// <param name = "parsableGeneration">
        ///     Defines if IParsable implementation and related methods are generated. Defaults to
        ///     <see cref = "ParsableGeneration.Generate"/>.
        /// </param>
        /// <param name = "underlyingTypeCreationMethodGeneration">
        ///     Defines if an extension method for value object creation is generated for the underlying type.
        ///     Defaults to <see cref = "UnderlyingTypeCreationMethodGeneration.Omit"/>.
        /// </param>
        /// <param name = "emptyValueName">
        ///     The name of the static property representing an empty value object, if applicable.
        ///     Defaults to "Empty".
        /// </param>
        public ValueObjectAttribute(ComparisonGeneration comparison = DefaultComparison, CastOperator toUnderlyingTypeCasting = DefaultToUnderlyingTypeCasting, CastOperator fromUnderlyingTypeCasting = DefaultFromUnderlyingTypeCasting, StringCaseSensitivity stringCaseSensitivity = DefaultStringCaseSensitivity, UnderlyingTypeEqualityGeneration underlyingTypeEqualityGeneration = DefaultUnderlyingTypeEqualityGeneration, FluentValidationExtensionsGeneration fluentValidationExtensionsGeneration = DefaultFluentValidationExtensionsGeneration, ParsableGeneration parsableGeneration = DefaultParsableGeneration, UnderlyingTypeCreationMethodGeneration underlyingTypeCreationMethodGeneration = DefaultUnderlyingTypeCreationMethodGeneration, string emptyValueName = DefaultEmptyValueName) : base(typeof(T), comparison, toUnderlyingTypeCasting, fromUnderlyingTypeCasting, stringCaseSensitivity, underlyingTypeEqualityGeneration, fluentValidationExtensionsGeneration, parsableGeneration, underlyingTypeCreationMethodGeneration, emptyValueName)
        {
        }
    }

    /// <summary>
    ///     Marks a type as a Value Object. The type that this is applied to should be partial so that the
    ///     source generator can augment it with equality, creation barriers, and any conversions.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
    public class ValueObjectAttribute : Attribute
    {
        internal const ComparisonGeneration DefaultComparison = ComparisonGeneration.UseUnderlying;
        internal const CastOperator DefaultToUnderlyingTypeCasting = CastOperator.None;
        internal const CastOperator DefaultFromUnderlyingTypeCasting = CastOperator.None;
        internal const StringCaseSensitivity DefaultStringCaseSensitivity = StringCaseSensitivity.CaseSensitive;
        internal const UnderlyingTypeEqualityGeneration DefaultUnderlyingTypeEqualityGeneration = UnderlyingTypeEqualityGeneration.Omit;
        internal const FluentValidationExtensionsGeneration DefaultFluentValidationExtensionsGeneration = FluentValidationExtensionsGeneration.Omit;
        internal const ParsableGeneration DefaultParsableGeneration = ParsableGeneration.Generate;
        internal const UnderlyingTypeCreationMethodGeneration DefaultUnderlyingTypeCreationMethodGeneration = UnderlyingTypeCreationMethodGeneration.Omit;
        internal const string DefaultEmptyValueName = "Empty";
        /// <summary>
        ///     Configures aspects of this individual value object.
        /// </summary>
        /// <param name = "underlyingType">The type of the underlying value that is being wrapped.</param>
        /// <param name = "comparison">
        ///     Species which comparison code is generated—defaults to
        ///     <see cref = "ComparisonGeneration.UseUnderlying"/> which hoists any IComparable implementations from the underlying
        ///     type.
        /// </param>
        /// <param name = "toUnderlyingTypeCasting">
        ///     Specifies the type of casting from wrapper to the underlying type - defaults to
        ///     <see cref = "CastOperator.Explicit"/>.
        /// </param>
        /// <param name = "fromUnderlyingTypeCasting">
        ///     Specifies the type of casting from the underlying type to wrapper - default to
        ///     <see cref = "CastOperator.Explicit"/>.
        /// </param>
        /// <param name = "stringCaseSensitivity">
        ///     When using a <see cref = "string "/> as a backing value, controls whether comparisons are case-sensitive.
        ///     Defaults to <see cref = "StringCaseSensitivity.CaseSensitive"/>.
        /// </param>
        /// <param name = "underlyingTypeEqualityGeneration">
        ///     Specifies whether to generate underlying value comparison operators, allowing this type to be compared for equality
        ///     to the
        ///     underlying type.
        ///     Defaults to <see cref = "UnderlyingTypeEqualityGeneration.Omit"/>
        /// </param>
        /// <param name = "fluentValidationExtensionsGeneration">
        ///     Specifies whether to generate FluentValidation extension methods for this value object.
        ///     Defaults to <see cref = "FluentValidationExtensionsGeneration.Omit"/>.
        /// </param>
        /// <param name = "parsableGeneration">
        ///     Defines if IParsable implementation and related methods are generated. Defaults to
        ///     <see cref = "ParsableGeneration.Generate"/>.
        /// </param>
        /// <param name = "underlyingTypeCreationMethodGeneration">
        ///     Defines if an extension method for value object creation is generated for the underlying type.
        ///     Defaults to <see cref = "UnderlyingTypeCreationMethodGeneration.Omit"/>.
        /// </param>
        /// <param name = "emptyValueName">
        ///     The name of the static property representing an empty value object, if applicable.
        ///     Defaults to "Empty".
        /// </param>
        public ValueObjectAttribute(Type? underlyingType = null !, ComparisonGeneration comparison = DefaultComparison, CastOperator toUnderlyingTypeCasting = DefaultToUnderlyingTypeCasting, CastOperator fromUnderlyingTypeCasting = DefaultFromUnderlyingTypeCasting, StringCaseSensitivity stringCaseSensitivity = DefaultStringCaseSensitivity, UnderlyingTypeEqualityGeneration underlyingTypeEqualityGeneration = DefaultUnderlyingTypeEqualityGeneration, FluentValidationExtensionsGeneration fluentValidationExtensionsGeneration = DefaultFluentValidationExtensionsGeneration, ParsableGeneration parsableGeneration = DefaultParsableGeneration, UnderlyingTypeCreationMethodGeneration underlyingTypeCreationMethodGeneration = DefaultUnderlyingTypeCreationMethodGeneration, string emptyValueName = DefaultEmptyValueName)
        {
        }
    }

    /// <summary>
    ///     The type of cast operator to generate.
    /// </summary>
    public enum CastOperator
    {
        /// <summary>
        ///     No cast operators are generated.
        /// </summary>
        None = 0,
        /// <summary>
        ///     Explicit cast operators are generated.
        /// </summary>
        Explicit = 1,
        /// <summary>
        ///     Implicit cast operators are generated.
        /// </summary>
        Implicit = 2,
    }

    /// <summary>
    ///     The generation of comparison code for a Value Object.
    /// </summary>
    public enum ComparisonGeneration
    {
        /// <summary>
        ///     Omits the IComparable interface and implementation. Useful for opaque types such as tokens or IDs where comparison
        ///     doesn't make sense.
        /// </summary>
        Omit = 0,
        /// <summary>
        ///     Uses the default IComparable from the underlying type.
        /// </summary>
        UseUnderlying = 1,
    }

    /// <summary>
    ///     Specifies whether to generate string comparers for a value object based on a string primitive type.
    /// </summary>
    public enum StringCaseSensitivity
    {
        /// <summary>
        ///     The backing string values are case-sensitive.
        /// </summary>
        CaseSensitive = 0,
        /// <summary>
        ///     The backing string values are case-sensitive.
        /// </summary>
        CaseInsensitive = 1,
    }

    /// <summary>
    ///     Defines if equality operators to the underlying values are generated.
    /// </summary>
    [Flags]
    public enum UnderlyingTypeEqualityGeneration
    {
        /// <summary>
        ///     Do not generate.
        /// </summary>
        Omit = 0,
        /// <summary>
        ///     Generate equals operators for the underlying type.
        /// </summary>
        GenerateOperators = 1 << 0,
        /// <summary>
        ///     Generate equals methods for the underlying type.
        /// </summary>
        GenerateMethods = 1 << 1,
        /// <summary>
        ///     Generate both operators and methods.
        /// </summary>
        GenerateOperatorsAndMethods = GenerateOperators | GenerateMethods,
    }

    /// <summary>
    ///     Defines if FluentValidation extension methods are generated.
    /// </summary>
    [Flags]
    public enum FluentValidationExtensionsGeneration
    {
        /// <summary>
        ///     Do not generate.
        /// </summary>
        Omit = 0,
        /// <summary>
        ///     Generate MustBeInitialized extension method.
        /// </summary>
        GenerateMustBeInitialized = 1 << 0,
        /// <summary>
        ///     Generate MustBeInitializedAndValid extension method.
        /// </summary>
        GenerateMustBeInitializedAndValid = 1 << 1,
        /// <summary>
        ///     Generate all methods.
        /// </summary>
        GenerateAll = GenerateMustBeInitialized | GenerateMustBeInitializedAndValid,
    }

    /// <summary>
    ///     Defines if IParsable implementation and related methods are generated.
    /// </summary>
    public enum ParsableGeneration
    {
        /// <summary>
        ///     Do not generate.
        /// </summary>
        Omit = 0,
        /// <summary>
        ///     Generate IParsable implementation and related methods.
        /// </summary>
        Generate = 1,
    }

    /// <summary>
    ///     Defines if an extension method for value object creation is generated for the underlying type.
    /// </summary>
    public enum UnderlyingTypeCreationMethodGeneration
    {
        /// <summary>
        ///     Do not generate.
        /// </summary>
        Omit = 0,
        /// <summary>
        ///     Generate Create method.
        /// </summary>
        Generate = 1,
    }
}
  
#nullable enable

using System;

namespace Dalion.ValueObjects.Samples {
    
    [System.Diagnostics.DebuggerDisplay("Password {Value}")]
    [System.Text.Json.Serialization.JsonConverter(typeof(PasswordSystemTextJsonConverter))]
    [System.ComponentModel.TypeConverter(typeof(PasswordTypeConverter))]
    public partial record struct Password : IEquatable<Password> {
        private readonly System.String _value;
        private readonly bool _initialized;
#pragma warning disable CS0414
        private readonly bool _isNullOrEmpty;
#pragma warning restore CS0414
        private readonly Validation _validation;
        private static readonly Type UnderlyingType = typeof(System.String);

        /// <summary>
        ///     Gets the underlying value of this <see cref="Password"/>.
        /// </summary>
        public System.String Value => _value;

        /// <summary>
        ///     Creates a new <see cref="Password"/>.
        /// </summary>
        [System.Diagnostics.DebuggerStepThrough]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        public Password()
        {
            _value = System.String.Empty;
            _initialized = false;
            _isNullOrEmpty = System.String.IsNullOrEmpty(_value);
            _validation ??= Validate(_value);
        }

        /// <summary>
        ///     Creates a new <see cref="Password"/>.
        /// </summary>
        /// <param name="value">The underlying value to create the value object from.</param>
        [System.Diagnostics.DebuggerStepThrough]
        [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
        private Password(System.String? value) {
            
            if (value == default) {
                _initialized = false;
                _value = System.String.Empty;
            } else {
                _initialized = true;
                _value = value;
            }
            _isNullOrEmpty = System.String.IsNullOrEmpty(_value);
            _validation ??= Validate(_value);
        }

        /// <summary>
        ///     Creates a new <see cref="Password"/> from the
        ///     given <see cref="System.String"/>.
        /// </summary>
        /// <param name="value">The underlying value to create the value object from.</param>
        /// <returns>A new <see cref="Password"/>.</returns>
        public static Password From(System.String? value) {
            if (value is null) {
                throw new System.ArgumentException("Cannot create an instance of Password from null.");
            }

            var vo = new Password(value);

            if (!vo.IsValid() && vo.Value is not null && !PasswordPreSetValueCache.PasswordPreSetValues.TryGetValue(vo.Value, out _)) {
                throw new System.ArgumentException(vo.GetValidationErrorMessage());
            }

            return vo;
        }

        /// <summary>
        ///     Tries to create a new <see cref="Password"/> from the
        ///     given <see cref="System.String"/>.
        /// </summary>
        /// <param name="value">The underlying value to create the value object from.</param>
        /// <param name="result">The resulting value object if the method returns <see langword="true"/>; otherwise, an uninitialized value object.</param>
        /// <returns><see langword="true"/> if the value object was created successfully; otherwise, <see langword="false"/>.</returns>
        public static bool TryFrom(System.String? value, out Password result) {
            if (value is null) {
                result = new Password();
                return false;
            }

            result = string.IsNullOrEmpty(value) ? Empty : new Password(value);
            return result.IsInitialized() && (Validate(result._value).IsSuccess || PasswordPreSetValueCache.PasswordPreSetValues.TryGetValue(value, out _));
        }

        /// <summary>
        ///     Represents a <see cref="Password"/> with a default underlying value.
        /// </summary>
        public static Password Empty { get; } = new Password(System.String.Empty);

        /// <summary>
        ///     Indicates whether this <see cref="Password"/> has been
        ///     initialized with a value.
        /// </summary>
        /// <returns><see langword="true" /> if this <see cref="Password"/> has been initialized; otherwise, <see langword="false" />.</returns>
        public bool IsInitialized() => _initialized;

        /// <inheritdoc />
        public bool Equals(Password? other)
        {
            if (other is null) return false;

            if (!other.Value.IsInitialized())
            {
                return !IsInitialized();
            }

            if (other.Value.IsInitialized() != IsInitialized())
            {
                return false;
            }
        
            return other.Value._isNullOrEmpty
                ? this._isNullOrEmpty
                : System.String.Equals(this._value, other.Value.Value, System.StringComparison.Ordinal);
        }

        /// <inheritdoc />
        public bool Equals(Password other)
        {
            if (!other.IsInitialized())
            {
                return !IsInitialized();
            }

            if (other.IsInitialized() != IsInitialized())
            {
                return false;
            }
        
            return other._isNullOrEmpty
                ? this._isNullOrEmpty
                : System.String.Equals(this._value, other.Value, System.StringComparison.Ordinal);
        }
        
        /// <inheritdoc />
        public bool Equals(Password? other, System.Collections.Generic.IEqualityComparer<Password> comparer)
        {
            if (other is null) return false;
            return comparer.Equals(this, other.Value);
        }
        
        /// <inheritdoc />
        public override int GetHashCode() {
            if (!IsInitialized()) return 0;
            return StringComparer.Ordinal.GetHashCode(this._value);
        }

        

        

        

        /// <summary>
        ///     An implicit conversion from <see cref="Password" /> to <see cref="System.String" />.
        /// </summary>
        /// <param name="id">The value to convert.</param>
        /// <returns>The System.String representation of the value object.</returns>
        public static explicit operator System.String(Password id)
        {
            return id.Value;
        }

        /// <inheritdoc />
        public override string ToString()
        {{
            return Value;
        }}

        /// <inheritdoc cref="M:System.String.ToString(System.IFormatProvider)" />
        public string ToString(IFormatProvider? provider)
        {{
            return Value.ToString(provider: provider);
        }}

        /// <summary>
        ///     Indicates whether this value object is valid.
        /// </summary>
        /// <returns><see langword="true" /> if this value object is valid; otherwise, <see langword="false" />.</returns>
        public bool IsValid() => _validation.IsSuccess;

        /// <summary>
        ///     Gets the validation error message if this value object is not valid.
        /// </summary>
        /// <returns>The validation error message if this value object is not valid; otherwise, <see langword="null" />.</returns>
        public string? GetValidationErrorMessage() => _validation.IsSuccess ? null : _validation.ErrorMessage;

        private class Validation
        {
            public static readonly Validation Ok = new(string.Empty);
            private readonly bool _isSuccess;
        
            private Validation(string reason)
            {
                ErrorMessage = reason;
                _isSuccess = string.IsNullOrEmpty(reason);
            }
        
            public string ErrorMessage { get; }
            public bool IsSuccess => _isSuccess;
        
            public System.Collections.Generic.Dictionary<object, object>? Data { get; private set; }
        
            public static Validation Invalid(string reason = "")
            {
                if (string.IsNullOrEmpty(reason))
                {
                    return new Validation("[none provided]");
                }
        
                return new Validation(reason);
            }
        
            public Validation WithData(object key, object value)
            {
                Data ??= new System.Collections.Generic.Dictionary<object, object>();
                Data[key] = value;
                return this;
            }
        }

        

        private class PasswordSystemTextJsonConverter : System.Text.Json.Serialization.JsonConverter<Password>
        {
            public override Password Read(
                ref System.Text.Json.Utf8JsonReader reader,
                Type typeToConvert,
                System.Text.Json.JsonSerializerOptions options
            )
            {
                if (reader.TokenType == System.Text.Json.JsonTokenType.Null) {
                    return new Password();
                }

                object? underlyingValue;
                underlyingValue = reader.GetString();

                try {
                    var typedUnderlyingValue = (System.String)underlyingValue!;
                    if (Password.TryFrom(typedUnderlyingValue, out var result)) {
                        return result;
                    }
                    throw new System.Text.Json.JsonException($"No matching Password pre-set value found for value '{typedUnderlyingValue}', or the underlying value is invalid.");
                } catch (System.Exception e) {
                    throw new System.Text.Json.JsonException("Could not create an initialized instance of Password.", e);
                }
            }

            public override void Write(
                System.Text.Json.Utf8JsonWriter writer,
                Password value,
                System.Text.Json.JsonSerializerOptions options
            )
            {
                object? underlyingValue = value.IsInitialized()
                    ? value.Value
                    : null;

                if (underlyingValue == null) {
                    writer.WriteNullValue();
                    return;
                }

                writer.WriteStringValue((string)underlyingValue);
            }
        }

        private class PasswordTypeConverter : System.ComponentModel.TypeConverter
        {
            public override bool CanConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, Type sourceType)
            {
                return sourceType is not null && (sourceType.IsAssignableFrom(typeof(Password)) || sourceType.IsAssignableFrom(UnderlyingType) || sourceType == typeof(string));
            }
            
            public override object? ConvertFrom(System.ComponentModel.ITypeDescriptorContext? context, System.Globalization.CultureInfo? culture, object value)
            {
                if (value is Password vo)
                {
                    return vo;
                }

                if (value == default) 
                {
                    return Empty;
                }
        
                if (value is System.String correctlyTypedValue)
                {
                    return correctlyTypedValue == default 
                        ? Empty 
                        : From(correctlyTypedValue);
                }
        
                if (value is string s)
                {
                    var underlyingValue = s;
                    return underlyingValue == default 
                        ? Empty 
                        : From((System.String)underlyingValue);
                }
    
                throw new NotSupportedException($@"Cannot convert from type '{value?.GetType()}'.");
            }
            
            public override bool CanConvertTo(System.ComponentModel.ITypeDescriptorContext? context, Type? destinationType)
            {
                return destinationType is not null && (destinationType.IsAssignableFrom(typeof(Password)) || destinationType.IsAssignableFrom(UnderlyingType) || destinationType == typeof(string));
            }
            
            public override object? ConvertTo(System.ComponentModel.ITypeDescriptorContext? context, System.Globalization.CultureInfo? culture, object? value, Type destinationType)
            {
                if (destinationType.IsAssignableFrom(typeof(Password)))
                {
                    if (value is Password vo)
                    {
                        return vo;
                    }
                    if (value is System.String correctlyTypedValue)
                    {
                        return From(correctlyTypedValue);
                    }
                    if (value is string s)
                    {
                        var underlyingValue = s;
                        return From(underlyingValue);
                    }
                }

                if (destinationType.IsAssignableFrom(UnderlyingType))
                {
                    if (value is Password vo)
                    {
                        return vo.Value;
                    }
                    if (value is System.String correctlyTypedValue)
                    {
                        return correctlyTypedValue;
                    }
                    if (value is string s)
                    {
                        var underlyingValue = s;
                        return underlyingValue;
                    }
                    return base.ConvertTo(context, culture ?? System.Globalization.CultureInfo.InvariantCulture, value, destinationType);
                }

                if (destinationType == typeof(string))
                {
                    if (value is Password vo)
                    {
                        return vo.Value;
                    }
                    if (value is System.IFormattable f)
                    {
                        return f.ToString(format: null, formatProvider: culture ?? System.Globalization.CultureInfo.InvariantCulture);
                    }
                    return value?.ToString();
                }

                throw new NotSupportedException($@"Cannot convert to type '{destinationType}'.");
            }
        }

        private static class PasswordPreSetValueCache {
            public static readonly System.Collections.Generic.Dictionary<System.String, Password> PasswordPreSetValues = new();
        
            static PasswordPreSetValueCache()
            {
                PasswordPreSetValues[Password.Empty.Value] = Password.Empty;

            }
        }
    }
    
}
  
// <auto-generated/>
#nullable enable
#pragma warning disable

namespace Dalion.ValueObjects.Samples
{
    partial record struct Password
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[^\\w\\s]).{8,}$</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match if at the beginning of the string.<br/>
        /// ○ Zero-width positive lookahead.<br/>
        ///     ○ Match a character other than '\n' greedily any number of times.<br/>
        ///     ○ Match a character in the set [a-z].<br/>
        /// ○ Zero-width positive lookahead.<br/>
        ///     ○ Match a character other than '\n' greedily any number of times.<br/>
        ///     ○ Match a character in the set [A-Z].<br/>
        /// ○ Zero-width positive lookahead.<br/>
        ///     ○ Match a character other than '\n' greedily any number of times.<br/>
        ///     ○ Match a Unicode digit.<br/>
        /// ○ Zero-width positive lookahead.<br/>
        ///     ○ Match a character other than '\n' greedily any number of times.<br/>
        ///     ○ Match a character in the set [^\w\s].<br/>
        /// ○ Match a character other than '\n' greedily at least 8 times.<br/>
        /// ○ Match if at the end of the string or if before an ending newline.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "<version>")]
        private static partial global::System.Text.RegularExpressions.Regex ValidPassword() => global::System.Text.RegularExpressions.Generated.ValidPassword_0.Instance;
    }
}

namespace System.Text.RegularExpressions.Generated
{
    using System;
    using System.Buffers;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;
    using System.Runtime.CompilerServices;
    using System.Text.RegularExpressions;
    using System.Threading;

    /// <summary>Custom <see cref="Regex"/>-derived type for the ValidPassword method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "<version>")]
    file sealed class ValidPassword_0 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly ValidPassword_0 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private ValidPassword_0()
        {
            base.pattern = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[^\\w\\s]).{8,}$";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 1;
        }
    
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // The pattern is anchored.  Validate the current position and try to match at it only.
                    if (TryFindNextPossibleStartingPosition(inputSpan) && !TryMatchAtCurrentPosition(inputSpan))
                    {
                        base.runtextpos = inputSpan.Length;
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Any possible match is at least 8 characters.
                    if (pos <= inputSpan.Length - 8)
                    {
                        // The pattern leads with a beginning (\A) anchor.
                        if (pos == 0)
                        {
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    char ch;
                    int charloop_starting_pos = 0, charloop_ending_pos = 0;
                    int charloop_starting_pos1 = 0, charloop_ending_pos1 = 0;
                    int charloop_starting_pos2 = 0, charloop_ending_pos2 = 0;
                    int charloop_starting_pos3 = 0, charloop_ending_pos3 = 0;
                    int charloop_starting_pos4 = 0, charloop_ending_pos4 = 0;
                    int stackpos = 0;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match if at the beginning of the string.
                    if (pos != 0)
                    {
                        return false; // The input didn't match.
                    }
                    
                    // Zero-width positive lookahead.
                    {
                        int positivelookahead_starting_pos = pos;
                        
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                        
                        int atomic_stackpos = stackpos;
                        
                        // Match a character other than '\n' greedily any number of times.
                        //{
                            charloop_starting_pos = pos;
                            
                            int iteration = slice.IndexOf('\n');
                            if (iteration < 0)
                            {
                                iteration = slice.Length;
                            }
                            
                            slice = slice.Slice(iteration);
                            pos += iteration;
                            
                            charloop_ending_pos = pos;
                            goto CharLoopEnd;
                            
                            CharLoopBacktrack:
                            
                            if (Utilities.s_hasTimeout)
                            {
                                base.CheckTimeout();
                            }
                            
                            if (charloop_starting_pos >= charloop_ending_pos ||
                                (charloop_ending_pos = inputSpan.Slice(charloop_starting_pos, charloop_ending_pos - charloop_starting_pos).LastIndexOfAnyInRange('a', 'z')) < 0)
                            {
                                return false; // The input didn't match.
                            }
                            charloop_ending_pos += charloop_starting_pos;
                            pos = charloop_ending_pos;
                            slice = inputSpan.Slice(pos);
                            
                            CharLoopEnd:
                        //}
                        
                        // Match a character in the set [a-z].
                        if (slice.IsEmpty || !char.IsAsciiLetterLower(slice[0]))
                        {
                            goto CharLoopBacktrack;
                        }
                        
                        stackpos = atomic_stackpos;
                        
                        pos = positivelookahead_starting_pos;
                        slice = inputSpan.Slice(pos);
                    }
                    
                    // Zero-width positive lookahead.
                    {
                        int positivelookahead_starting_pos1 = pos;
                        
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                        
                        int atomic_stackpos1 = stackpos;
                        
                        // Match a character other than '\n' greedily any number of times.
                        //{
                            charloop_starting_pos1 = pos;
                            
                            int iteration1 = slice.IndexOf('\n');
                            if (iteration1 < 0)
                            {
                                iteration1 = slice.Length;
                            }
                            
                            slice = slice.Slice(iteration1);
                            pos += iteration1;
                            
                            charloop_ending_pos1 = pos;
                            goto CharLoopEnd1;
                            
                            CharLoopBacktrack1:
                            
                            if (Utilities.s_hasTimeout)
                            {
                                base.CheckTimeout();
                            }
                            
                            if (charloop_starting_pos1 >= charloop_ending_pos1 ||
                                (charloop_ending_pos1 = inputSpan.Slice(charloop_starting_pos1, charloop_ending_pos1 - charloop_starting_pos1).LastIndexOfAnyInRange('A', 'Z')) < 0)
                            {
                                return false; // The input didn't match.
                            }
                            charloop_ending_pos1 += charloop_starting_pos1;
                            pos = charloop_ending_pos1;
                            slice = inputSpan.Slice(pos);
                            
                            CharLoopEnd1:
                        //}
                        
                        // Match a character in the set [A-Z].
                        if (slice.IsEmpty || !char.IsAsciiLetterUpper(slice[0]))
                        {
                            goto CharLoopBacktrack1;
                        }
                        
                        stackpos = atomic_stackpos1;
                        
                        pos = positivelookahead_starting_pos1;
                        slice = inputSpan.Slice(pos);
                    }
                    
                    // Zero-width positive lookahead.
                    {
                        int positivelookahead_starting_pos2 = pos;
                        
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                        
                        int atomic_stackpos2 = stackpos;
                        
                        // Match a character other than '\n' greedily any number of times.
                        //{
                            charloop_starting_pos2 = pos;
                            
                            int iteration2 = slice.IndexOf('\n');
                            if (iteration2 < 0)
                            {
                                iteration2 = slice.Length;
                            }
                            
                            slice = slice.Slice(iteration2);
                            pos += iteration2;
                            
                            charloop_ending_pos2 = pos;
                            goto CharLoopEnd2;
                            
                            CharLoopBacktrack2:
                            
                            if (Utilities.s_hasTimeout)
                            {
                                base.CheckTimeout();
                            }
                            
                            if (charloop_starting_pos2 >= charloop_ending_pos2)
                            {
                                return false; // The input didn't match.
                            }
                            pos = --charloop_ending_pos2;
                            slice = inputSpan.Slice(pos);
                            
                            CharLoopEnd2:
                        //}
                        
                        // Match a Unicode digit.
                        if (slice.IsEmpty || !char.IsDigit(slice[0]))
                        {
                            goto CharLoopBacktrack2;
                        }
                        
                        stackpos = atomic_stackpos2;
                        
                        pos = positivelookahead_starting_pos2;
                        slice = inputSpan.Slice(pos);
                    }
                    
                    // Zero-width positive lookahead.
                    {
                        int positivelookahead_starting_pos3 = pos;
                        
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                        
                        int atomic_stackpos3 = stackpos;
                        
                        // Match a character other than '\n' greedily any number of times.
                        //{
                            charloop_starting_pos3 = pos;
                            
                            int iteration3 = slice.IndexOf('\n');
                            if (iteration3 < 0)
                            {
                                iteration3 = slice.Length;
                            }
                            
                            slice = slice.Slice(iteration3);
                            pos += iteration3;
                            
                            charloop_ending_pos3 = pos;
                            goto CharLoopEnd3;
                            
                            CharLoopBacktrack3:
                            
                            if (Utilities.s_hasTimeout)
                            {
                                base.CheckTimeout();
                            }
                            
                            if (charloop_starting_pos3 >= charloop_ending_pos3)
                            {
                                return false; // The input didn't match.
                            }
                            pos = --charloop_ending_pos3;
                            slice = inputSpan.Slice(pos);
                            
                            CharLoopEnd3:
                        //}
                        
                        // Match a character in the set [^\w\s].
                        if (slice.IsEmpty || ((ch = slice[0]) < 128 ? ("쇿\uffff\ufffeﰀ\u0001砀\u0001"[ch >> 4] & (1 << (ch & 0xF))) == 0 : !RegexRunner.CharInClass((char)ch, "\u0001\0\v\0\u0002\u0004\u0005\u0003\u0001\u0006\t\u0013\0d")))
                        {
                            goto CharLoopBacktrack3;
                        }
                        
                        stackpos = atomic_stackpos3;
                        
                        pos = positivelookahead_starting_pos3;
                        slice = inputSpan.Slice(pos);
                    }
                    
                    // Match a character other than '\n' greedily at least 8 times.
                    //{
                        charloop_starting_pos4 = pos;
                        
                        int iteration4 = slice.IndexOf('\n');
                        if (iteration4 < 0)
                        {
                            iteration4 = slice.Length;
                        }
                        
                        if (iteration4 < 8)
                        {
                            return false; // The input didn't match.
                        }
                        
                        slice = slice.Slice(iteration4);
                        pos += iteration4;
                        
                        charloop_ending_pos4 = pos;
                        charloop_starting_pos4 += 8;
                        goto CharLoopEnd4;
                        
                        CharLoopBacktrack4:
                        
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                        
                        if (charloop_starting_pos4 >= charloop_ending_pos4)
                        {
                            return false; // The input didn't match.
                        }
                        pos = --charloop_ending_pos4;
                        slice = inputSpan.Slice(pos);
                        
                        CharLoopEnd4:
                    //}
                    
                    // Match if at the end of the string or if before an ending newline.
                    if (pos < inputSpan.Length - 1 || ((uint)pos < (uint)inputSpan.Length && inputSpan[pos] != '\n'))
                    {
                        goto CharLoopBacktrack4;
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                }
            }
        }

    }
    
    /// <summary>Helper methods used by generated <see cref="Regex"/>-derived implementations.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "<version>")]
    file static class Utilities
    {
        /// <summary>Default timeout value set in <see cref="AppContext"/>, or <see cref="Regex.InfiniteMatchTimeout"/> if none was set.</summary>
        internal static readonly TimeSpan s_defaultTimeout = AppContext.GetData("REGEX_DEFAULT_MATCH_TIMEOUT") is TimeSpan timeout ? timeout : Regex.InfiniteMatchTimeout;
        
        /// <summary>Whether <see cref="s_defaultTimeout"/> is non-infinite.</summary>
        internal static readonly bool s_hasTimeout = s_defaultTimeout != Regex.InfiniteMatchTimeout;
    }
}

]