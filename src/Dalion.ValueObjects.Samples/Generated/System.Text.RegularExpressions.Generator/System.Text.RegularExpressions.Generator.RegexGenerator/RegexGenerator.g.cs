// <auto-generated/>
#nullable enable
#pragma warning disable

namespace Dalion.ValueObjects.Samples
{
    partial record struct Password
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[^\\w\\s]).{8,}$</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match if at the beginning of the string.<br/>
        /// ○ Zero-width positive lookahead.<br/>
        ///     ○ Match a character other than '\n' greedily any number of times.<br/>
        ///     ○ Match a character in the set [a-z].<br/>
        /// ○ Zero-width positive lookahead.<br/>
        ///     ○ Match a character other than '\n' greedily any number of times.<br/>
        ///     ○ Match a character in the set [A-Z].<br/>
        /// ○ Zero-width positive lookahead.<br/>
        ///     ○ Match a character other than '\n' greedily any number of times.<br/>
        ///     ○ Match a Unicode digit.<br/>
        /// ○ Zero-width positive lookahead.<br/>
        ///     ○ Match a character other than '\n' greedily any number of times.<br/>
        ///     ○ Match a character in the set [^\w\s].<br/>
        /// ○ Match a character other than '\n' greedily at least 8 times.<br/>
        /// ○ Match if at the end of the string or if before an ending newline.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "10.0.13.2411")]
        private static partial global::System.Text.RegularExpressions.Regex ValidPassword() => global::System.Text.RegularExpressions.Generated.ValidPassword_0.Instance;
    }
}

namespace Dalion.ValueObjects.Samples
{
    partial record struct ResourceGroupName
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>^[A-Za-z0-9](?:[A-Za-z0-9_-]{1,61}[A-Za-z0-9])$</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match if at the beginning of the string.<br/>
        /// ○ Match an ASCII letter or digit.<br/>
        /// ○ Match a character in the set [\-0-9A-Z_a-z] greedily at least 1 and at most 61 times.<br/>
        /// ○ Match an ASCII letter or digit.<br/>
        /// ○ Match if at the end of the string or if before an ending newline.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "10.0.13.2411")]
        private static partial global::System.Text.RegularExpressions.Regex ValidResourceGroupName() => global::System.Text.RegularExpressions.Generated.ValidResourceGroupName_1.Instance;
    }
}

namespace System.Text.RegularExpressions.Generated
{
    using System;
    using System.Buffers;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;
    using System.Runtime.CompilerServices;
    using System.Text.RegularExpressions;
    using System.Threading;

    /// <summary>Custom <see cref="Regex"/>-derived type for the ValidPassword method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "10.0.13.2411")]
    file sealed class ValidPassword_0 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly ValidPassword_0 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private ValidPassword_0()
        {
            base.pattern = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[^\\w\\s]).{8,}$";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 1;
        }
            
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // The pattern is anchored.  Validate the current position and try to match at it only.
                    if (TryFindNextPossibleStartingPosition(inputSpan) && !TryMatchAtCurrentPosition(inputSpan))
                    {
                        base.runtextpos = inputSpan.Length;
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Any possible match is at least 8 characters.
                    if (pos <= inputSpan.Length - 8)
                    {
                        // The pattern leads with a beginning (\A) anchor.
                        if (pos == 0)
                        {
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    char ch;
                    int charloop_starting_pos = 0, charloop_ending_pos = 0;
                    int charloop_starting_pos1 = 0, charloop_ending_pos1 = 0;
                    int charloop_starting_pos2 = 0, charloop_ending_pos2 = 0;
                    int charloop_starting_pos3 = 0, charloop_ending_pos3 = 0;
                    int charloop_starting_pos4 = 0, charloop_ending_pos4 = 0;
                    int stackpos = 0;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match if at the beginning of the string.
                    if (pos != 0)
                    {
                        return false; // The input didn't match.
                    }
                    
                    // Zero-width positive lookahead.
                    {
                        int positivelookahead_starting_pos = pos;
                        
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                        
                        int atomic_stackpos = stackpos;
                        
                        // Match a character other than '\n' greedily any number of times.
                        //{
                            charloop_starting_pos = pos;
                            
                            int iteration = slice.IndexOf('\n');
                            if (iteration < 0)
                            {
                                iteration = slice.Length;
                            }
                            
                            slice = slice.Slice(iteration);
                            pos += iteration;
                            
                            charloop_ending_pos = pos;
                            goto CharLoopEnd;
                            
                            CharLoopBacktrack:
                            
                            if (Utilities.s_hasTimeout)
                            {
                                base.CheckTimeout();
                            }
                            
                            if (charloop_starting_pos >= charloop_ending_pos ||
                                (charloop_ending_pos = inputSpan.Slice(charloop_starting_pos, charloop_ending_pos - charloop_starting_pos).LastIndexOfAnyInRange('a', 'z')) < 0)
                            {
                                return false; // The input didn't match.
                            }
                            charloop_ending_pos += charloop_starting_pos;
                            pos = charloop_ending_pos;
                            slice = inputSpan.Slice(pos);
                            
                            CharLoopEnd:
                        //}
                        
                        // Match a character in the set [a-z].
                        if (slice.IsEmpty || !char.IsAsciiLetterLower(slice[0]))
                        {
                            goto CharLoopBacktrack;
                        }
                        
                        stackpos = atomic_stackpos;
                        
                        pos = positivelookahead_starting_pos;
                        slice = inputSpan.Slice(pos);
                    }
                    
                    // Zero-width positive lookahead.
                    {
                        int positivelookahead_starting_pos1 = pos;
                        
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                        
                        int atomic_stackpos1 = stackpos;
                        
                        // Match a character other than '\n' greedily any number of times.
                        //{
                            charloop_starting_pos1 = pos;
                            
                            int iteration1 = slice.IndexOf('\n');
                            if (iteration1 < 0)
                            {
                                iteration1 = slice.Length;
                            }
                            
                            slice = slice.Slice(iteration1);
                            pos += iteration1;
                            
                            charloop_ending_pos1 = pos;
                            goto CharLoopEnd1;
                            
                            CharLoopBacktrack1:
                            
                            if (Utilities.s_hasTimeout)
                            {
                                base.CheckTimeout();
                            }
                            
                            if (charloop_starting_pos1 >= charloop_ending_pos1 ||
                                (charloop_ending_pos1 = inputSpan.Slice(charloop_starting_pos1, charloop_ending_pos1 - charloop_starting_pos1).LastIndexOfAnyInRange('A', 'Z')) < 0)
                            {
                                return false; // The input didn't match.
                            }
                            charloop_ending_pos1 += charloop_starting_pos1;
                            pos = charloop_ending_pos1;
                            slice = inputSpan.Slice(pos);
                            
                            CharLoopEnd1:
                        //}
                        
                        // Match a character in the set [A-Z].
                        if (slice.IsEmpty || !char.IsAsciiLetterUpper(slice[0]))
                        {
                            goto CharLoopBacktrack1;
                        }
                        
                        stackpos = atomic_stackpos1;
                        
                        pos = positivelookahead_starting_pos1;
                        slice = inputSpan.Slice(pos);
                    }
                    
                    // Zero-width positive lookahead.
                    {
                        int positivelookahead_starting_pos2 = pos;
                        
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                        
                        int atomic_stackpos2 = stackpos;
                        
                        // Match a character other than '\n' greedily any number of times.
                        //{
                            charloop_starting_pos2 = pos;
                            
                            int iteration2 = slice.IndexOf('\n');
                            if (iteration2 < 0)
                            {
                                iteration2 = slice.Length;
                            }
                            
                            slice = slice.Slice(iteration2);
                            pos += iteration2;
                            
                            charloop_ending_pos2 = pos;
                            goto CharLoopEnd2;
                            
                            CharLoopBacktrack2:
                            
                            if (Utilities.s_hasTimeout)
                            {
                                base.CheckTimeout();
                            }
                            
                            if (charloop_starting_pos2 >= charloop_ending_pos2)
                            {
                                return false; // The input didn't match.
                            }
                            pos = --charloop_ending_pos2;
                            slice = inputSpan.Slice(pos);
                            
                            CharLoopEnd2:
                        //}
                        
                        // Match a Unicode digit.
                        if (slice.IsEmpty || !char.IsDigit(slice[0]))
                        {
                            goto CharLoopBacktrack2;
                        }
                        
                        stackpos = atomic_stackpos2;
                        
                        pos = positivelookahead_starting_pos2;
                        slice = inputSpan.Slice(pos);
                    }
                    
                    // Zero-width positive lookahead.
                    {
                        int positivelookahead_starting_pos3 = pos;
                        
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                        
                        int atomic_stackpos3 = stackpos;
                        
                        // Match a character other than '\n' greedily any number of times.
                        //{
                            charloop_starting_pos3 = pos;
                            
                            int iteration3 = slice.IndexOf('\n');
                            if (iteration3 < 0)
                            {
                                iteration3 = slice.Length;
                            }
                            
                            slice = slice.Slice(iteration3);
                            pos += iteration3;
                            
                            charloop_ending_pos3 = pos;
                            goto CharLoopEnd3;
                            
                            CharLoopBacktrack3:
                            
                            if (Utilities.s_hasTimeout)
                            {
                                base.CheckTimeout();
                            }
                            
                            if (charloop_starting_pos3 >= charloop_ending_pos3)
                            {
                                return false; // The input didn't match.
                            }
                            pos = --charloop_ending_pos3;
                            slice = inputSpan.Slice(pos);
                            
                            CharLoopEnd3:
                        //}
                        
                        // Match a character in the set [^\w\s].
                        if (slice.IsEmpty || ((ch = slice[0]) < 128 ? ("쇿\uffff\ufffeﰀ\u0001砀\u0001"[ch >> 4] & (1 << (ch & 0xF))) == 0 : !RegexRunner.CharInClass((char)ch, "\u0001\0\v\0\u0002\u0004\u0005\u0003\u0001\u0006\t\u0013\0d")))
                        {
                            goto CharLoopBacktrack3;
                        }
                        
                        stackpos = atomic_stackpos3;
                        
                        pos = positivelookahead_starting_pos3;
                        slice = inputSpan.Slice(pos);
                    }
                    
                    // Match a character other than '\n' greedily at least 8 times.
                    //{
                        charloop_starting_pos4 = pos;
                        
                        int iteration4 = slice.IndexOf('\n');
                        if (iteration4 < 0)
                        {
                            iteration4 = slice.Length;
                        }
                        
                        if (iteration4 < 8)
                        {
                            return false; // The input didn't match.
                        }
                        
                        slice = slice.Slice(iteration4);
                        pos += iteration4;
                        
                        charloop_ending_pos4 = pos;
                        charloop_starting_pos4 += 8;
                        goto CharLoopEnd4;
                        
                        CharLoopBacktrack4:
                        
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                        
                        if (charloop_starting_pos4 >= charloop_ending_pos4)
                        {
                            return false; // The input didn't match.
                        }
                        pos = --charloop_ending_pos4;
                        slice = inputSpan.Slice(pos);
                        
                        CharLoopEnd4:
                    //}
                    
                    // Match if at the end of the string or if before an ending newline.
                    if (pos < inputSpan.Length - 1 || ((uint)pos < (uint)inputSpan.Length && inputSpan[pos] != '\n'))
                    {
                        goto CharLoopBacktrack4;
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the ValidResourceGroupName method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "10.0.13.2411")]
    file sealed class ValidResourceGroupName_1 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly ValidResourceGroupName_1 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private ValidResourceGroupName_1()
        {
            base.pattern = "^[A-Za-z0-9](?:[A-Za-z0-9_-]{1,61}[A-Za-z0-9])$";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 1;
        }
            
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // The pattern is anchored.  Validate the current position and try to match at it only.
                    if (TryFindNextPossibleStartingPosition(inputSpan) && !TryMatchAtCurrentPosition(inputSpan))
                    {
                        base.runtextpos = inputSpan.Length;
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Any possible match is at least 3 characters.
                    if (pos <= inputSpan.Length - 3)
                    {
                        // The pattern leads with a beginning (\A) anchor.
                        if (pos == 0)
                        {
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    char ch;
                    int charloop_starting_pos = 0, charloop_ending_pos = 0;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match if at the beginning of the string.
                    if (pos != 0)
                    {
                        return false; // The input didn't match.
                    }
                    
                    // Match an ASCII letter or digit.
                    if (slice.IsEmpty || !char.IsAsciiLetterOrDigit(slice[0]))
                    {
                        return false; // The input didn't match.
                    }
                    
                    // Match a character in the set [\-0-9A-Z_a-z] greedily at least 1 and at most 61 times.
                    //{
                        pos++;
                        slice = inputSpan.Slice(pos);
                        charloop_starting_pos = pos;
                        
                        int iteration = 0;
                        while (iteration < 61 && (uint)iteration < (uint)slice.Length && ((ch = slice[iteration]) < '{' && ("\0\0 Ͽ\ufffe蟿\ufffe߿"[ch >> 4] & (1 << (ch & 0xF))) != 0))
                        {
                            iteration++;
                        }
                        
                        if (iteration == 0)
                        {
                            return false; // The input didn't match.
                        }
                        
                        slice = slice.Slice(iteration);
                        pos += iteration;
                        
                        charloop_ending_pos = pos;
                        charloop_starting_pos++;
                        goto CharLoopEnd;
                        
                        CharLoopBacktrack:
                        
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                        
                        if (charloop_starting_pos >= charloop_ending_pos ||
                            (charloop_ending_pos = inputSpan.Slice(charloop_starting_pos, charloop_ending_pos - charloop_starting_pos).LastIndexOfAny(Utilities.s_asciiLettersAndDigits)) < 0)
                        {
                            return false; // The input didn't match.
                        }
                        charloop_ending_pos += charloop_starting_pos;
                        pos = charloop_ending_pos;
                        slice = inputSpan.Slice(pos);
                        
                        CharLoopEnd:
                    //}
                    
                    // Match an ASCII letter or digit.
                    if (slice.IsEmpty || !char.IsAsciiLetterOrDigit(slice[0]))
                    {
                        goto CharLoopBacktrack;
                    }
                    
                    // Match if at the end of the string or if before an ending newline.
                    if (2 < slice.Length || (1 < slice.Length && slice[1] != '\n'))
                    {
                        goto CharLoopBacktrack;
                    }
                    
                    // The input matched.
                    pos++;
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                }
            }
        }

    }
    
    /// <summary>Helper methods used by generated <see cref="Regex"/>-derived implementations.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "10.0.13.2411")]
    file static class Utilities
    {
        /// <summary>Default timeout value set in <see cref="AppContext"/>, or <see cref="Regex.InfiniteMatchTimeout"/> if none was set.</summary>
        internal static readonly TimeSpan s_defaultTimeout = AppContext.GetData("REGEX_DEFAULT_MATCH_TIMEOUT") is TimeSpan timeout ? timeout : Regex.InfiniteMatchTimeout;
        
        /// <summary>Whether <see cref="s_defaultTimeout"/> is non-infinite.</summary>
        internal static readonly bool s_hasTimeout = s_defaultTimeout != Regex.InfiniteMatchTimeout;
        
        /// <summary>Supports searching for characters in or not in "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".</summary>
        internal static readonly SearchValues<char> s_asciiLettersAndDigits = SearchValues.Create("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz");
    }
}
